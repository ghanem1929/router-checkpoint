{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = _ref => {\n  let {\n    acceptRegex = /[\\d]/gi,\n    disabled,\n    disableMaskedInput,\n    ignoreInvalidInputs,\n    inputFormat,\n    inputProps,\n    label,\n    mask,\n    onChange,\n    rawValue,\n    readOnly,\n    rifmFormatter,\n    TextFieldProps,\n    validationError\n  } = _ref;\n  const utils = useUtils();\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const {\n    shouldUseMaskedInput,\n    maskToUse\n  } = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text\n\n  const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat));\n  const isAcceptedValue = rawValue === null || utils.isValid(parsedValue);\n\n  if (isAcceptedValue && !utils.isEqual(innerInputValue, parsedValue)) {\n    // When dev set a new valid value, we trust them\n    const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(parsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};","map":{"version":3,"names":["_extends","React","useRifm","useUtils","maskedDateFormatter","getDisplayDate","checkMaskIsValidForCurrentFormat","getMaskFromCurrentFormat","useMaskedInput","acceptRegex","disabled","disableMaskedInput","ignoreInvalidInputs","inputFormat","inputProps","label","mask","onChange","rawValue","readOnly","rifmFormatter","TextFieldProps","validationError","utils","formatHelperText","getFormatHelperText","shouldUseMaskedInput","maskToUse","useMemo","computedMaskToUse","formatter","st","parsedValue","date","innerInputValue","setInnerInputValue","useState","innerDisplayedInputValue","setInnerDisplayedInputValue","isAcceptedValue","isValid","isEqual","newDisplayDate","handleChange","text","finalString","parse","undefined","rifmProps","value","format","inputStateArgs","event","currentTarget","error","placeholder","type"],"sources":["/home/ghanem19/Desktop/GoMyCode/router/node_modules/@mui/x-date-pickers/internals/hooks/useMaskedInput.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = ({\n  acceptRegex = /[\\d]/gi,\n  disabled,\n  disableMaskedInput,\n  ignoreInvalidInputs,\n  inputFormat,\n  inputProps,\n  label,\n  mask,\n  onChange,\n  rawValue,\n  readOnly,\n  rifmFormatter,\n  TextFieldProps,\n  validationError\n}) => {\n  const utils = useUtils();\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const {\n    shouldUseMaskedInput,\n    maskToUse\n  } = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text\n\n  const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat));\n  const isAcceptedValue = rawValue === null || utils.isValid(parsedValue);\n\n  if (isAcceptedValue && !utils.isEqual(innerInputValue, parsedValue)) {\n    // When dev set a new valid value, we trust them\n    const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(parsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}